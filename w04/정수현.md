## 5.5 샌드박스 패턴

- 전역 네임스페이스 보호
- 원하는 유형 별로 모듈의 인스턴스를 여러 개 만들 수도 있다.
    - 이 인스턴스들은 각각 독립적으로 동작

### 전역 생성자

- 이 생성자를 통해 객체 생성

```js
new Sandbox(function (box)) {

}
```

### 모듈 추가하기

- `Sandbox()` 생성자 함수 역시 객체이므로, `modules`라는 프로퍼티를 추가할 수 있다.

```js
Sandbox.modules = {};

Sandbox.modules.dom = function (box) {
    // ...
}
Sandbox.modules.event = function (box) {
    // ...
}
Sandbox.modules.ajax = function (box) {
    // ...
}
```

## 5.6 스태틱 멤버

- 인스턴스에 따라 달라지지 않는 프로파티와 메서드
- [`static`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes/static) 키워드 - 클래스의 정적 메소드를 정의하는 키워드

```js
class StaticMethodCall {
  constructor() {
    console.log(StaticMethodCall.staticMethod());
    // 'static method has been called.'

    console.log(this.constructor.staticMethod());
    // 'static method has been called.'
  }

  static staticMethod() {
    return "static method has been called.";
  }
}
```

### 비공개 스태틱 멤버

- [자바스크립트의 private](https://velog.io/@shroad1802/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-private)


## 5.7 객체 상수

- 명명 규칙을 사용하여 상수를 모두 대문자로 쓰기도 한다.
- 실제로도 값이 변경되지 않게 하고 싶다면, 비공개 프로퍼티를 만든 후 값을 설정하는 메서드(setter)없이 값을 반환하는 메서드(getter)만 제공하는 방법 고려해볼만 하다.
    - 그러나 대부분의 경우에는 단순히 명명 규칙만으로도 층분하기 때문에 이 방법은 좀 과도할 수 있다.
- [객체 대신 Map을 더 사용해보기](https://velog.io/@surim014/use-maps-more-and-objects-less?ref=codenary)
- lookup table

## 5.8 체이닝 패턴

- 객체에 연쇄적으로 메서드를 호출할 수 있도록 하는 패턴
- 메서드 체이닝
- 장점
    - 코드량이 줄고 코드가 간결해져 하나의 문장처럼 읽히게 할 수 있다는 장점
    - 함수의 기능을 쪼개는데 집중할 수 있게 됨 -> 유지보수 개선
- 단점
    - 디버깅하기 어렵다.

## 5.9 method() 메서드

- 생성자 본문 내에서 인스턴스 프로퍼티를 추가할 수 있다.
- 체이닝 패턴 사용

```js
var Person = function (name) {
    this.name = name;
}
method('getName', function () {
    return this.name;
})
method('setName', function (name) {
    this.name = name;
    return this;
})
```

# 6. 코드 재사용 패턴

## 6.1 클래스 방식 vs 새로운 방식의 상속 패턴

## 6.2 클래스 방식의 상속을 사용할 경우 예상되는 산출물

- 목표 : Child()라는 생성자 함수로 생성된 객체들이 다른 생성자 함수인 Parent()의 프로퍼티를 가지도록 하는 것
```js
function Parent(name) {
    this.name = name || 'Adam';
}

Parent.prototype.say = function () {
    return this.name;
}

function Child(name) {}

inherit(Child, Parent)
```

## 6.3 클래스 방식의 상속 패턴 - 1. 기본 패턴

- Parent() 생성자를 사용해 객체를 생성한 다음 이 객체를 Child()의 프로토타입에 할당하는 것
- prototype 함수가 아니라 객체를 가리키게 하는 것이 중요
- 프로토타입이 부모 생성자 함수 자체가 아니라 부모 생성자 함수로 생성한 객체 인스턴스를 가리켜야 한다.
- `new Child()`를 사용해 객체를 생성하면 프로토타입을 통해 `Parent()` 인스턴스의 기능을 물려받게 된다.

```js
function inherit(C, P) {
    C.prototype = new P();
}
```

### 패턴 1의 단점

- 부모 객체의 this에 추가된 객체 자신의 프로퍼티와 프로토타입 프로퍼티를 모두 물려받게 된다.
- 대부분의 경우 객체 자신의 프로퍼티는 특정 인스턴스에 한정되어 재사용할 수 없기 때문에 필요가 없다.
- 자식 생성자에 인자를 넘겨도 부모 생성자에게 전달하지 못한다.
    ```js
    var s = new Child('Seth');
    s.say(); // Adam
    ```
- 자식 인스턴스를 생성할 때마다 부모 객체를 계속해서 재생성하는 셈이고, 따라서 매우 비효율적이다.

## 6.4 클래스 방식의 상속 패턴 - 2. 생성자 빌려쓰기

- 자식에서 부모로 인자를 전달하지 못했던 패턴 1의 문제 해결
- 부모의 생성자 함수의 this에 자식 객체를 바인딩한 다음 -> 자식 생성자가 받은 인자들을 모두 넘긴다.
- 부모 생성자 함수 내부의 this에 추가된 프로퍼티만 물려받게 되고,
- 프로토타입에 추가된 멤버는 상속되지 않는다.
- 자식 객체는 상속된 멤버의 복사본을 받게 된다.
```js
function Child(a, c, b, d) {
    Parent.apply(this, arguments);
}
```


### 생성자 빌려쓰기를 적용한 다중 상속

- 생성자 빌려쓰기 패턴을 사용하면 생성자를 하나 이상 빌려쓰는 다중 상속을 구현할 수 있다.

```js
function Cat() {
    this.legs = 4;
    this.say = function () {
        return "미야오";
    }
}

function Bird() {
    this.wings = 2;
    this.fly = true;
}

function CatWings() {
    Cat.apply(this);
    Bird.apply(this);
}

var jane = new CatWings();
console.dir(jane)

/* 
    fly true
    legs 4
    wings 2
    say function()
*/
```

### 생성자 빌려쓰기 패턴의 장단점

- 단점
    - 프로토타입이 전혀 상속되지 않는다.
- 장점
    - 부모 생성자 자신의 멤버에 대한 복사본을 가져올 수 있다
    - 자식이 실수로 부모의 프로퍼티를 덮어쓰는 위험을 방지할 수 있다.