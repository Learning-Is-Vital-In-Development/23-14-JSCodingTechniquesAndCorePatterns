# 3. 리터럴과 생성자


## 3.1 객체 리터럴

- 중괄호 `{}`로 감싼다.
- 객체 내의 프로퍼티와 메서드를 쉼표로 분리한다.
- 프로퍼티명과 프로퍼티 값은 콜론(`:`)으로 분리한다.
- 객체를 변수에 할당할 때는 닫는 중괄호 뒤에 세미콜론을 빼먹지 않도록 하라.

```js
const car = {
    goes: "far"
};
```
### 생성자 함수로 객체 생성하기

```js
const car = new Object();
car.goes = "far";
```
## 3.2 사용자 정의 생성자 함수

- 빈 객체가 생성된다.
    - 이 객체는 `this`라는 변수로 참조할 수 있고
    - 해당 함수의 프로토타입을 상속받는다.
- `this`로 참조되는 객체에 프로퍼티와 메서드가 추가된다.
- 마지막에 다른 객체가 명시적으로 반환되지 않을 경우, `this`로 참조된 이 객체가 반환된다.

### 생성자의 반환값

- 생성자 함수를 `new`와 함께 호출하면 항상 객체가 반환됨
- 기본값: `this`로 찿ㅁ조되는 객체
- 함수 내에 return 문을 쓰지 않았더라도 생성자는 암묵적으로 `this`를 반환
- 반환값이 될 객체를 따로 정할 수도 있다.
- 생성자에서는 어떤 객체라도 반환할 수 있다.
    - 객체가 아닌 것(문자열이나 false 등)을 반환하려고 시도하면, 에러가 발생하진 않지만 그냥 무시되고 this에 의해 참조된 객체가 대신 반환된다.

## 3.3 `new`를 강제하는 패턴

- 생성자를 호출할 때 new를 빼먹는다고 해서 문법 오류나 런타임 에러가 발생하지는 않지만, 논리적인 오류가 생겨 예기치 못한 결과가 나올 수 있다.
- new를 뺴먹으면 생성자 내부의 this가 전역 객체를 가리키게 되기 때문이다.
    - 브라우저에서라면 `this`가 `window`를 가리키게 된다.
- ES5에서는 이러한 동작 방식의 문제에 대한 해결책으로, strict mode에서는 this가 전역 객체를 가리키지 않도록 했다.

### 명명 규칙
- 생성자 함수 명의 첫글자를 대문자로,
    - ex) `MyConstructor`
- 일반 함수와 메서드는 소문자를 사용한다.
    - ex) `myFunction`

### that 사용

```js
function Waffle() {
    var that = {};
    that.tastes = "yummy";
    return that;
}
```
- this에 모든 멤버를 추가하는 대시, that에 모든 멤버를 추가한 후 that을 반환
- 이 패턴의 문제는 프로토타입과의 연결 고리를 잃어버리게 된다는 점이다. 
    - 즉, Waffle 프로토타입에 추가한 멤버를 객체에서 사용할 수 없다.

> that이라는 변수명은 관습적인 것으로, 언어에 정의되어 있진 않다. 어떤 이름이라도 쓸 수 있다. 흔히 사용되는 변수명으로는 `self`, `me` 등이 있다.


### 스스로 호출하는 생성자
- 인스턴스 객체에서 프로토타입의 프로퍼티들을 사용할 수 있게 하려면
    - 생성자 내부에서 this가 해당 생성자의 인스턴스인지를 확인하고
    - 그렇지 않은 경우 `new` 와 함께 스스로를 재호출

```js
function Waffle() {
    if (!(this instanceof Waffle)) {
        return new Waffle();
    }
    this.tastes = "yummy";
}
```

## 3.4 배열 리터럴

- 각 원소는 쉼표로 분리하고 전체 목록을 대괄호(`[]`)로 감싼다.
- 객체나 다른 배열 등 어떤 타입의 값이든 배열 원소로 지정할 수있다.

### 배열 생성자의 특이성(`new Array()`)

- Array 생성자의 숫자 하나를 전달할 경우
    - 이 값은 배열의 첫번째 원소 값이 되는게 아니라 배열의 길이를 지정한다.
    - 정수가 아닌 부동소수점을 가지는 수를 전달할 경우 배열의 길이로 유효한 값이 아니기 때문에 에러가 발생한다.

### 배열인지 판별
- `Array.isArray()``


## 3.5 JSON

- JavaScript Object Notation
- 객체 리터럴과 달리 프로퍼티명을 따옴표로 감싸야 한다.
- 함수나 정규식 리터럴을 사용할 수 없다.

### JSON 다루기

- `JSON.parse`
    - JSON 문자열을 파싱하여 객체로 변환
- `JSON.stringify`
    - 객체 또는 배열(또는 원시 데이터 타입)을 인자로 받아 JSON 문자열로 직렬화

## 3.6 정규 표현식 리터럴

- 매칭에 사용되는 정규식 패턴을 슬래시로 감싼다.
- 패턴 변경자
    - `g`: 전역 매칭
    - `m`: 여러 줄 매칭
    - `i`: 대소문자 구분 없이 매칭
- 패턴 변경자는 순서에 상관없이 쓸 수 있으며 여러 개를 함께 써도 된다.

## 3.7 원시 데이터 타입 래퍼

- 원시 데이터 타입
- 원시 래퍼 타입

## 3.8 에러 객체

- 자바스크립트에는 여러 가지 에러 생성자가 내장되어 있다.
    - `Error()`
    - `SyntaxError()`
    - `TypeError()`
- throw 문과 함께 사용
- 에러 객체의 프로퍼티
    - `name`
        - 객체를 생성한 생성자 함수의 name 프로퍼티
        - 범용적인 "Error"일 수도 있고, "RangeError"와 같이 좀 더 특화된 생성자일 수도이싿.
    - `message`
        - 객체를 생성할 때 생성자에 전달된 문자열

# 4. 함수


## 4.1 배경 지식

- 함수는 일급(first-class) 객체이다.
- 함수는 스코프를 제공한다.
- 런타임, 즉 프로그램 실행 중에 동적으로 생성할 수 있다.
- 변수에 할당할 수 있고, 다른 변수에 참조를 복사할 수 있으며
- 확장 가능하고
- 몇몇 특별한 경우를 제외하면 삭제할 수 있다.
- 다른 함수의 인자로 전달할 수 있고, 다른 함수의 반환값이 될 수 있다.
- 자기 자신의 프로퍼티와 메서드를 가질 수 있다.

### 용어 정리

**기명함수 표현식(named function expression)**'
```js
var add = function add(a,b) {
    return a + b
}
```
**무명함수 표현식(unnamed function expression) 또는 익명함수(anonymous function)**

```js
var add = function (a, b) {
    return a + b
}
```

**함수 선언문(funciton declaration)**
```js
function foo() {}
```

### 함수 선언문 vs 함수 표현식 : 이름과 호이스팅

|함수선언문|함수표현식|
|:-:|:-:|
|- 변수에 할당할 수 없다. <br>- 함수 이름을 생략할 수 없다. <br>- 런타임 이전에 자바스크립트 엔진에 의해 함수 객체가 먼저 생성됨<br>- 런타임에서 함수 선언문이 실행되기 이전에 함수를 참조할 수 있으며 호출할 수도 있다.|- 변수에 할당할 수 있다. <br>- 함수 이름을 생략할 수 있다. <br>- 함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문이다. <br>- 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생. <br>- 함수 표현식으로 정의한 함수는 함수 표현식 이후에 참조, 호출해야 한다.|


```js
//  함수 선언문
console.log(add(2, 5)) // 7

function add(a,b) {
    return a + b
}
```

```js
console.log(add(2, 5)) // Reference Error

const add = (a,b) => {
    return a + b
}
```

## 4.2 콜백 패턴

- 함수는 객체다
    - 즉 함수를 다른 함수에 인자로 전달할 수 있다.
    - 괄호없이 전달
        - 함수의 참조만 전달
        - 실행은 추후 적절한 시점에!
    - 괄호를 붙이면 함수가 실행

### 비동기 이벤트 리스너

```js
document.addEventListener("click", console.log, false)
```

- 이벤트는 사용자의 상호작용에 따라 발생할 수도, 발생하지 않을 수도 있다.
- 함수를 이벤트가 발생하는 시점에 따라 실행시키기 위해 콜백인자로 전달한다.

### 타임아웃
- 브라우저의 window 객체에 의해 제공되는 타임아웃 메서드
    - setTimeout(), setInterval()
- 콜백함수를 받아서 실행시킨다.

### 라이브러리에서의 콜백
- 콜백은 라이브러리를 설계할 때 유용한 간단하고 강력한 패턴이다.
- 소프트웨어 라이브러리에 들어갈 코드는 가능한 범용적이고 재사용할 수 있어야 한다.
- 콜백은 이러한 일반화에 도움
- 생각할 수 있는 모든 기능을 예측하고 구현할 필요는 없다.
- 이는 라이브러리를 쓸데 없이 부풀릴 뿐이고 대부분의 사용자는 그런 커다란 기능들의 덩어리를 절대 필요로 하지 않는다.
- 대신 핵심 기능에 집중하고 콜백의 형태로 "연결고리(hook)"를 제공하라.
- 콜백함수를 활용하면 조금 더 쉽게 라이브러리 메서드를 만들고 확장하고 가다듬을 수 있다.